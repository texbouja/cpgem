#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import sys
import os
import tempfile
from pathlib import Path
from xml.etree import ElementTree as ET
import cairosvg
from PIL import Image
import io
import yaml

def get_default_values(svg_path):
    """Extract default values from SVG template"""
    try:
        tree = ET.parse(svg_path)
        root = tree.getroot()
        
        defaults = {
            'concours': None,
            'filiere': None,
            'session': None,
            'epreuve': None,
            'auteur': None
        }
        
        ns = {'svg': 'http://www.w3.org/2000/svg'}
        
        # Map des anciens noms vers les nouveaux
        field_mapping = {
            'concours': 'eco',
            'filiere': 'fil',
            'session': 'ses',
            'epreuve': 'epr',
            'auteur': 'aut'
        }
        
        for new_name, old_name in field_mapping.items():
            elem = root.find(f'.//svg:text[@id="{old_name}"]', ns)
            if elem is not None and elem.text:
                defaults[new_name] = elem.text.strip()
        
        return defaults
    except Exception as e:
        print(f"Erreur lors de la lecture des valeurs par défaut: {e}", file=sys.stderr)
        return None

def modify_svg_template(input_svg, output_svg, options):
    """Modify the SVG template with new values"""
    try:
        tree = ET.parse(input_svg)
        root = tree.getroot()
        ns = {'svg': 'http://www.w3.org/2000/svg'}
        
        # Map des noms d'options vers les IDs SVG
        field_mapping = {
            'concours': 'eco',
            'filiere': 'fil',
            'session': 'ses',
            'epreuve': 'epr',
            'auteur': 'aut'
        }
        
        for opt_name, value in options.items():
            if value is not None and opt_name in field_mapping:
                elem = root.find(f'.//svg:text[@id="{field_mapping[opt_name]}"]', ns)
                if elem is not None:
                    elem.text = value
        
        tree.write(output_svg, encoding='utf-8', xml_declaration=True)
        
        with open(output_svg, 'r+', encoding='utf-8') as f:
            content = f.read()
            if content.startswith('<?xml'):
                content = content.replace('<?xml', '<?xml', 1)
            f.seek(0)
            f.write(content)
            f.truncate()
            
        return True
    except Exception as e:
        print(f"Erreur lors de la modification du template: {e}", file=sys.stderr)
        return False

def convert_to_image(svg_path, output_path, **kwargs):
    """Convert SVG to other image formats with exact output dimensions"""
    try:
        ext = os.path.splitext(output_path)[1].lower()
        quality = kwargs.get('quality', 80)
        
        # Paramètres de dimension fixe
        output_width = 1200
        output_height = 630
        
        if ext == '.png':
            cairosvg.svg2png(
                url=svg_path,
                write_to=output_path,
                output_width=output_width,
                output_height=output_height
            )
        elif ext == '.webp':
            png_data = cairosvg.svg2png(
                url=svg_path,
                output_width=output_width,
                output_height=output_height
            )
            img = Image.open(io.BytesIO(png_data))
            img.save(output_path, 'WEBP', quality=quality)
        elif ext == '.jpg' or ext == '.jpeg':
            png_data = cairosvg.svg2png(
                url=svg_path,
                output_width=output_width,
                output_height=output_height
            )
            img = Image.open(io.BytesIO(png_data))
            img.convert('RGB').save(output_path, 'JPEG', quality=quality)
        else:
            raise ValueError(f"Format non supporté: {ext}")
        
        return True
    except Exception as e:
        print(f"Erreur lors de la conversion: {str(e)}", file=sys.stderr)
        return False

def process_single_job(template_path, base_name, formats, options, output_dir='.', quality=90, scale=2.0):
    """Process a single conversion job"""
    temp_svg_path = None
    try:
        # Create output directory if needed
        os.makedirs(output_dir, exist_ok=True)
        
        for fmt in formats:
            output_path = os.path.join(output_dir, f"{base_name}.{fmt}")
            
            if fmt == 'svg':
                # Direct SVG output
                if not modify_svg_template(template_path, output_path, options):
                    return False
                print(f"Fichier généré: {output_path}")
            else:
                # Need conversion - create temp SVG first
                if temp_svg_path is None:
                    temp_svg_path = os.path.join(output_dir, f"temp_{base_name}.svg")
                    if not modify_svg_template(template_path, temp_svg_path, options):
                        return False
                
                # Convert to target format
                if not convert_to_image(
                    temp_svg_path,
                    output_path,
                    quality=quality,
                    scale=scale
                ):
                    return False
                print(f"Fichier généré: {output_path} (qualité: {quality}, scale: {scale}x)")
        
        return True
    finally:
        # Clean up temp file
        if temp_svg_path and os.path.exists(temp_svg_path):
            os.remove(temp_svg_path)

def process_batch_yaml(template_path, yaml_file, output_dir='.', quality=90, scale=2.0):
    """Process a batch of jobs from YAML file"""
    try:
        with open(yaml_file, 'r') as f:
            jobs = yaml.safe_load(f)
        
        if not jobs:
            print("Aucun job trouvé dans le fichier YAML", file=sys.stderr)
            return False
        
        success = True
        for base_name, config in jobs.items():
            print(f"\nTraitement du job: {base_name}")
            
            # Get formats (default to ['svg'] if not specified)
            formats = config.get('format', ['svg'])
            if isinstance(formats, str):
                formats = [formats.strip()]
            elif isinstance(formats, list) and len(formats) == 1 and isinstance(formats[0], str):
                formats = [formats[0].strip()]
            
            # Prepare options (with 'concours' instead of 'ecole')
            options = {
                'concours': str(config.get('concours')) if config.get('concours') is not None else None,
                'filiere': str(config.get('filiere')) if config.get('filiere') is not None else None,
                'session': str(config.get('session')) if config.get('session') is not None else None,
                'epreuve': str(config.get('epreuve')) if config.get('epreuve') is not None else None,
                'auteur': str(config.get('auteur')) if config.get('auteur') is not None else None
            }
            
            if not process_single_job(
                template_path,
                base_name,
                formats,
                options,
                output_dir,
                quality,
                scale
            ):
                success = False
                print(f"Erreur lors du traitement du job: {base_name}", file=sys.stderr)
        
        return success
    except Exception as e:
        print(f"Erreur lors du traitement du fichier YAML: {str(e)}", file=sys.stderr)
        return False

def main():
    template_path = Path(__file__).parent / 'concours-template.svg'
    
    if not template_path.exists():
        print(f"Erreur: Fichier template introuvable: {template_path}", file=sys.stderr)
        sys.exit(1)
    
    defaults = get_default_values(template_path)
    if defaults is None:
        sys.exit(1)
    
    parser = argparse.ArgumentParser(
        description="Générateur de sujets de concours avec traitement par lot YAML",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Options avec formes courtes et longues
    parser.add_argument('-c', '--concours', help="Nom de l'école/concours", default=defaults['concours'])
    parser.add_argument('-f', '--filiere', help="Filière", default=defaults['filiere'])
    parser.add_argument('-s', '--session', help="Session", default=defaults['session'])
    parser.add_argument('-e', '--epreuve', help="Épreuve", default=defaults['epreuve'])
    parser.add_argument('-a', '--auteur', help="Auteur du corrigé", default=defaults['auteur'])
    parser.add_argument('-o', '--output-file', help="Fichier de sortie (ignoré si -y est utilisé)")
    
    # Options de traitement par lot
    parser.add_argument('-y', '--yaml', help="Fichier YAML de traitement par lot")
    parser.add_argument('-d', '--output-dir', default='.', help="Répertoire de sortie pour les fichiers générés")
    
    # Options de qualité
    parser.add_argument('--quality', type=int, default=90, help="Qualité pour les formats WebP/JPEG (0-100)")
    parser.add_argument('--scale', type=float, default=2.0, help="Facteur d'échelle pour la conversion")
    
    args = parser.parse_args()
    
    # Process batch YAML if specified
    if args.yaml:
        if not process_batch_yaml(
            template_path,
            args.yaml,
            args.output_dir,
            args.quality,
            args.scale
        ):
            sys.exit(1)
    else:
        # Process single job
        if not args.output_file:
            print("Erreur: L'option -o/--output-file est requise pour le traitement unitaire", file=sys.stderr)
            sys.exit(1)
        
        output_ext = os.path.splitext(args.output_file)[1].lower()
        output_is_svg = (output_ext == '.svg')
        
        options = {
            'concours': args.concours,
            'filiere': args.filiere,
            'session': args.session,
            'epreuve': args.epreuve,
            'auteur': args.auteur
        }
        
        temp_svg_path = None
        try:
            if not output_is_svg:
                base_name = os.path.splitext(os.path.basename(args.output_file))[0]
                temp_svg_path = os.path.join(args.output_dir, f"temp_{base_name}.svg")
                final_output = args.output_file
            else:
                final_output = args.output_file
            
            if not modify_svg_template(template_path, final_output if output_is_svg else temp_svg_path, options):
                sys.exit(1)
            
            if not output_is_svg:
                if not convert_to_image(
                    temp_svg_path, 
                    final_output, 
                    quality=args.quality, 
                    scale=args.scale
                ):
                    sys.exit(1)
                print(f"Fichier généré: {final_output} (qualité: {args.quality}, scale: {args.scale}x)")
            else:
                print(f"Fichier généré: {final_output}")
        
        finally:
            if temp_svg_path and os.path.exists(temp_svg_path):
                os.remove(temp_svg_path)

if __name__ == '__main__':
    main()